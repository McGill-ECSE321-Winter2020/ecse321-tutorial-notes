=== Unit Testing Service Methods in Backend

==== Service Testing Setup with Mockito

. Add the following dependencies to the project:
+
[source,gradle]
----
testImplementation 'org.mockito:mockito-core:2.+'
testImplementation 'org.mockito:mockito-junit-jupiter:2.18.3'

testRuntime 'org.junit.jupiter:junit-jupiter-engine:5.3.1'
----
+
[TIP]
Finding configuration settings for your Gradle/Maven projects is very simple by searaching for them on MVNRepository: https://mvnrepository.com/

. If you also would like to run your project from Eclipse, add an additional dependency: 
+
[source,gradle]
----
testImplementation 'org.junit.platform:junit-platform-launcher:1.3.1'
----



. Create a test class (in case you don't already have one) `TestEventregistrationService` in the corresponding package under `src/test/java`:
+
[source,java]
----
package ca.mcgill.ecse321.eventregistration.service;

import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;


@ExtendWith(MockitoExtension.class)
public class TestEventRegistrationService {

}
----

. Build your project to ensure its dependencies are correctly loaded.

==== Implementing Unit Tests for Service Class

. Add the following static imports for methods: 
+
[source,java]
----
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;
----

. Add the following imports to the test class:
+
[source,java]
----
import java.sql.Date;
import java.sql.Time;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.stubbing.Answer;

import ca.mcgill.ecse321.eventregistration.dao.EventRepository;
import ca.mcgill.ecse321.eventregistration.dao.PersonRepository;
import ca.mcgill.ecse321.eventregistration.dao.RegistrationRepository;
import ca.mcgill.ecse321.eventregistration.model.Event;
import ca.mcgill.ecse321.eventregistration.model.Person;
import ca.mcgill.ecse321.eventregistration.model.Registration;
----



. Create the DAO mock for person 
+
[source,java]
----
@Mock
private PersonRepository personDao;

@InjectMocks
private EventRegistrationService service;

private static final String PERSON_KEY = "TestPerson";
private static final String NONEXISTING_KEY = "NotAPerson";

@BeforeEach
public void setMockOutput() {
    when(personDao.findPersonByName(anyString())).thenAnswer( (InvocationOnMock invocation) -> {
        if(invocation.getArgument(0).equals(PERSON_KEY)) {
            Person person = new Person();
            person.setName(PERSON_KEY);
            return person;
        } else {
            return null;
        }
    });
}
----

. Add test cases 
+
[source,java]
----
@Test
public void testCreatePerson() {
	assertEquals(0, service.getAllPersons().size());

	String name = "Oscar";

	try {
		person = service.createPerson(name);
	} catch (IllegalArgumentException e) {
		// Check that no error occurred
		fail();
	}

	assertEquals(name, person.getName());
}

@Test
public void testCreatePersonNull() {
	String name = null;
	String error = null;

	try {
		person = service.createPerson(name);
	} catch (IllegalArgumentException e) {
		error = e.getMessage();
	}

	// check error
	assertEquals("Person name cannot be empty!", error);
}
----

. Copy the link:https://gist.githubusercontent.com/imbur/d8836dc9f44ece65186a43ac80a259fd/raw/06eb5d533a937f0d4e496e68ae2d0ee8894d73c7/TestEventRegistrationService.java[complete test suite from here].

. Run the tests as JUnit/Gradle tests and interpret the test error messages! You should see only a few (at least one) tests passing.

. Update the implementation (i.e., replace the current service method codes with the ones provided below) of the following methods with input validation in the `EventRegistrationService` service class to make the tests pass (TDD -- Test-Driven Development)
+
[source,java]
----
@Transactional
public Person createPerson(String name) {
	if (name == null || name.trim().length() == 0) {
		throw new IllegalArgumentException("Person name cannot be empty!");
	}
	Person person = new Person();
	person.setName(name);
	personRepository.save(person);
	return person;
}
----
+
[source,java]
----
@Transactional
public Person getPerson(String name) {
    if (name == null || name.trim().length() == 0) {
        throw new IllegalArgumentException("Person name cannot be empty!");
    }
    Person person = personRepository.findPersonByName(name);
    return person;
}
----
+
[source,java]
----
@Transactional
public Event getEvent(String name) {
    if (name == null || name.trim().length() == 0) {
        throw new IllegalArgumentException("Event name cannot be empty!");
    }
    Event event = eventRepository.findEventByName(name);
    return event;
}
----
+
[source,java]
----
@Transactional
public Event createEvent(String name, Date date, Time startTime, Time endTime) {
    // Input validation
    String error = "";
    if (name == null || name.trim().length() == 0) {
        error = error + "Event name cannot be empty! ";			
    }
    if (date == null) {
        error = error + "Event date cannot be empty! ";			
    }
    if (startTime == null) {
        error = error + "Event start time cannot be empty! ";			
    }
    if (endTime == null) {
        error = error + "Event end time cannot be empty! ";			
    }
    if (endTime != null && startTime != null && endTime.before(startTime)) {
        error = error + "Event end time cannot be before event start time!";			
    }
    error = error.trim();
    if (error.length() > 0) {
        throw new IllegalArgumentException(error);			
    }

    Event event = new Event();
    event.setName(name);
    event.setDate(date);
    event.setStartTime(startTime);
    event.setEndTime(endTime);
    eventRepository.save(event);
    return event;
}
----
+
[source,java]
----
@Transactional
public Registration register(Person person, Event event) {
    String error = "";
    if (person == null) {
        error = error + "Person needs to be selected for registration! ";
    } else if (!personRepository.existsById(person.getName())) {
        error = error + "Person does not exist! ";
    }
    if (event == null) {
        error = error + "Event needs to be selected for registration!";
    } else if (!eventRepository.existsById(event.getName())) {
        error = error + "Event does not exist!";
    }
    if (registrationRepository.existsByPersonAndEvent(person, event)) {
        error = error + "Person is already registered to this event!";
    }
    error = error.trim();

    if (error.length() > 0) {			
        throw new IllegalArgumentException(error);
    }

    Registration registration = new Registration();
	registration.setId(person.getName().hashCode() * event.getName().hashCode());
    registration.setPerson(person);
    registration.setEvent(event);

    registrationRepository.save(registration);

    return registration;
}
----
+
[source,java]
----
@Transactional
public List<Event> getEventsAttendedByPerson(Person person) {
    if (person == null ) {
        throw new IllegalArgumentException("Person cannot be null!");
    }
    List<Event> eventsAttendedByPerson = new ArrayList<>();
    for (Registration r : registrationRepository.findByPerson(person)) {
        eventsAttendedByPerson.add(r.getEvent());
    }
    return eventsAttendedByPerson;
}
----

. Run the tests again, and all should be passing this time.
 



























==== Testing Services

. See the link:https://gist.githubusercontent.com/imbur/d8836dc9f44ece65186a43ac80a259fd/raw/b60ddaf6c86860abe119908b139ca087f1f5ff6e/TestEventRegistrationService.java[complete test suite here].

. Run the tests and interpret the test error messages! You should see only a few (at least one) tests passing.

. Update the implementation (i.e., replace the current service method codes with the ones provided below) of the following methods with input validation in the `EventRegistrationService` service class to make the tests pass (Test-Driven Development)
+
[source,java]
----
@Transactional
public Person createPerson(String name) {
	if (name == null || name.trim().length() == 0) {
		throw new IllegalArgumentException("Person name cannot be empty!");
	}
	Person person = new Person();
	person.setName(name);
	personRepository.save(person);
	return person;
}
----
+
[source,java]
----
@Transactional
public Person getPerson(String name) {
    if (name == null || name.trim().length() == 0) {
        throw new IllegalArgumentException("Person name cannot be empty!");
    }
    Person person = personRepository.findPersonByName(name);
    return person;
}
----
+
[source,java]
----
@Transactional
public Event getEvent(String name) {
    if (name == null || name.trim().length() == 0) {
        throw new IllegalArgumentException("Event name cannot be empty!");
    }
    Event event = eventRepository.findEventByName(name);
    return event;
}
----
+
[source,java]
----
@Transactional
public Event createEvent(String name, Date date, Time startTime, Time endTime) {
    // Input validation
    String error = "";
    if (name == null || name.trim().length() == 0) {
        error = error + "Event name cannot be empty! ";			
    }
    if (date == null) {
        error = error + "Event date cannot be empty! ";			
    }
    if (startTime == null) {
        error = error + "Event start time cannot be empty! ";			
    }
    if (endTime == null) {
        error = error + "Event end time cannot be empty! ";			
    }
    if (endTime != null && startTime != null && endTime.before(startTime)) {
        error = error + "Event end time cannot be before event start time!";			
    }
    error = error.trim();
    if (error.length() > 0) {
        throw new IllegalArgumentException(error);			
    }

    Event event = new Event();
    event.setName(name);
    event.setDate(date);
    event.setStartTime(startTime);
    event.setEndTime(endTime);
    eventRepository.save(event);
    return event;
}
----
+
[source,java]
----
@Transactional
public Registration register(Person person, Event event) {
    String error = "";
    if (person == null) {
        error = error + "Person needs to be selected for registration! ";
    } else if (!personRepository.existsById(person.getName())) {
        error = error + "Person does not exist! ";
    }
    if (event == null) {
        error = error + "Event needs to be selected for registration!";
    } else if (!eventRepository.existsById(event.getName())) {
        error = error + "Event does not exist!";
    }
    if (registrationRepository.existsByPersonAndEvent(person, event)) {
        error = error + "Person is already registered to this event!";
    }
    error = error.trim();

    if (error.length() > 0) {			
        throw new IllegalArgumentException(error);
    }

    Registration registration = new Registration();
	registration.setId(person.getName().hashCode() * event.getName().hashCode());
    registration.setPerson(person);
    registration.setEvent(event);

    registrationRepository.save(registration);

    return registration;
}
----
+
[source,java]
----
@Transactional
public List<Event> getEventsAttendedByPerson(Person person) {
    if (person == null ) {
        throw new IllegalArgumentException("Person cannot be null!");
    }
    List<Event> eventsAttendedByPerson = new ArrayList<>();
    for (Registration r : registrationRepository.findByPerson(person)) {
        eventsAttendedByPerson.add(r.getEvent());
    }
    return eventsAttendedByPerson;
}
----

. Run the tests again, and all should be passing this time.
 


















Previously, we used CRUD repository objects for each data type of the domain model and implemented use-cases in service classes. In this section, we will Implement REST API for eventregistration (people, events and registrations) 


and expose Sping Data.

If you would like to, you can obtain a version of the project that already has the changes from the previous tutorials link:https://github.com/imbur/eventregistration-w2020[here].

